{
    "preguntes": [
        {
            "id": 1,
            "text": "Dada una imagen I de tipo float, e I2=I/2",
            "respostes": {
                "a": "La localización de los puntos SIFT de I e I2 coincide",
                "b": "La localización de la mitad de los puntos SIFT de I coinciden con los puntos SIFT de I2",
                "c": "No solo la localización de los puntos SIFT de I e I2 coincide, pero además los descriptores de I2 se pueden obtener dividiendo los descriptores de I por 2",
                "d": "Ninguno de los anteriores"
            },
            "correcta": "a",
            "type": "multi"
        },
        {
            "id": 2,
            "text": "El ORB es una alternativa de:",
            "respostes": {
                "a": "El detector de esquina de Harris",
                "b": "El detector SIFT de características de la imagen",
                "c": "Los puntos CENSURE",
                "d": "Ninguno de los anteriores"
            },
            "correcta": "b",
            "type": "multi"
        },
        {
            "id": 3,
            "text": "El método RANSAC se utiliza:",
            "respostes": {
                "a": "Para detectar puntos característicos (esquinas) en la imagen equivalentes a los puntos SIFT",
                "b": "Para detectar la transformación de los puntos SIFT de una imagen a otra",
                "c": "Para calcular la precisión de la detección de puntos características en una imagen (como por ejemplo puntos SIFT)",
                "d": "Ninguno de los anteriores"
            },
            "correcta": "b",
            "type": "multi"
        },
        {
            "id": 4,
            "text": "El banco de filtros de la Gausiana visto en clase para caracterizar texturas:",
            "respostes": {
                "a": "Contiene derivadas de la Gausiana de orden 1",
                "b": "Contiene derivadas de la Gausiana de orden 2",
                "c": "Contiene derivadas de la Gausiana de orden 0, 1 y 2",
                "d": "Ninguno de los anteriores"
            },
            "correcta": "c",
            "type": "multi"
        },
        {
            "id": 5,
            "text": "En el Local Binary Patterns, usamos el histograma para:",
            "respostes": {
                "a": "Calcular la frecuencia de los números decimales que codifican los correspondientes números binarios representando la relación entre las intensidades del píxel central y sus vecinos",
                "b": "Para construir un histograma del gradiente",
                "c": "Para calcular la frecuencia de los valores del pixel central y de los vecinos",
                "d": "Ninguno de los anteriores"
            },
            "correcta": "a",
            "type": "multi"
        },
        {
            "id": 6,
            "text": "El descriptor de texturas basado en Local binary patterns es invariante a:",
            "respostes": {
                "a": "La orientación de la textura",
                "b": "La escala de la textura",
                "c": "El cambio de contraste de las imágenes",
                "d": "Ninguno de los anteriores"
            },
            "correcta": "c",
            "type": "multi"
        },
        {
            "id": 7,
            "text": "En una imagen integral construida a partir de cualquier imagen, el píxel más abajo y a la derecha:",
            "respostes": {
                "a": "Es la suma de todos los píxeles de la imagen integral",
                "b": "Es la suma de todos los píxeles de la imagen original",
                "c": "Es el resultado de aplicar una convolución sobre la imagen original con una máscara de tamaño de la imagen original",
                "d": "Ninguno de los anteriores"
            },
            "correcta": "b",
            "type": "multi"
        },
        {
            "id": 8,
            "text": "Los clasificadores débiles en el clasificador Adaboost se necesitan para construir el clasificador Adaboost donde añadimos el siguiente clasificador débil para",
            "respostes": {
                "a": "mejorar el último clasificador débil añadido",
                "b": "mejorar clasificador Adaboost construido hasta la iteración actual",
                "c": "para convolucionar con alguna de las características Haar",
                "d": "ninguno de los anteriores"
            },
            "correcta": "b",
            "type": "multi"
        },
        {
            "id": 9,
            "text": "El clasificador cascada para detectar caras en imágenes combina:",
            "respostes": {
                "a": "Características Haar",
                "b": "Clasificadores débiles",
                "c": "Clasificadores Adaboost",
                "d": "Ninguno de los anteriores"
            },
            "correcta": "c",
            "type": "multi"
        },
        {
            "id": 10,
            "text": "El clasificador cascada para detectar caras en imágenes:",
            "respostes": {
                "a": "Sirve sólo para detectar caras ya que las características Haar están diseñadas para 'imitar' características faciales",
                "b": "Es aplicable para detectar cualquier tipo de objetos siempre y cuando se utilizan imágenes etiquetadas de estos objetos para entrenar los adalboosts",
                "c": "Es aplicable para detectar los eigenfaces y así reconocer las caras",
                "d": "Ninguno de los anteriores"
            },
            "correcta": "b",
            "type": "multi"
        },
        {
            "id": 11,
            "text": "En los eigenfaces, usamos el trick de los eigenfaces para",
            "respostes": {
                "a": "Simplificar el proceso de obtener los vectores propios a partir de imágenes de tamaño más pequeño",
                "b": "Poder aprender a reconocer las caras con menos ejemplos de caras de aprendizaje",
                "c": "Para compactar el conjunto de imágenes de caras en un espacio de dimensionalidad menor",
                "d": "Ninguno de los anteriores"
            },
            "correcta": "c",
            "type": "multi"
        },
        {
            "id": 12,
            "text": "En los eigenfaces, el trick de los eigenfaces tiene sentido cuando:",
            "respostes": {
                "a": "El número de datos de aprendizaje es menor que el número de píxeles de las imágenes",
                "b": "El número de datos de aprendizaje es mayor que el número de píxeles de las imágenes",
                "c": "Cuando queremos reducir el número de vectores propios",
                "d": "Ninguno de los anteriores"
            },
            "correcta": "a",
            "type": "multi"
        },
        {
            "id": 13,
            "text": "En las redes neuronales convolucionales, la función de pérdida (loss) se utiliza:",
            "respostes": {
                "a": "Dentro del descenso del gradiente para actualizar los pesos de la red",
                "b": "Para calcular cuántas neuronas ha de tener cada capa",
                "c": "Para calcular cuántas capas ha de tener la red neuronal",
                "d": "Ninguno de los anteriores"
            },
            "correcta": "a",
            "type": "multi"
        },
        {
            "id": 14,
            "text": "El proceso de entrenamiento de una red (sin capas congeladas) sirve para modificar:",
            "respostes": {
                "a": "Los pesos de las capas completamente conectadas",
                "b": "Los pesos de las máscaras convolucionales",
                "c": "Los parámetros de la función de pérdida",
                "d": "Los pesos de las capas completamente conectadas y los pesos de las máscaras convolucionales"
            },
            "correcta": "d",
            "type": "multi"
        },
        {
            "id": 81,
            "text": "(EXAMEN 2023)El método de Eigenfaces utiliza como espacio de características:",
            "respostes": {
                "a": "Las derivadas de las Gaussianas",
                "b": "El espacio de los eigenfaces",
                "c": "El espacio definido por los histogramas de los tres canales de las imágenes en color",
                "d": "Ninguna de las anteriores"
            },
            "correcta": "b",
            "type": "multi"
            },
            {
            "id": 82,
            "text": "(EXAMEN 2023)Los valores propios de la matriz de covarianza de las caras de aprendizaje em el método de los eigenfaces sirve para:",
            "respostes": {
                "a": "Descartar eigenfaces redundantes e innecesarias",
                "b": "Encontrar imagenes defectuosas en el conjunto de las imagenes de aprendizaje",
                "c": "Determinar si una imagen contiene una cara o no",
                "d": "Ninguna de las anteriores"
            },
            "correcta": "a",
            "type": "multi"
            },
            {
            "id": 83,
            "text": "(EXAMEN 2023)Dado el método de los eigenfaces, k eigenfaces u1,u2,...,uk , la cara promedia es /X y una imagen de cara X, aplicando la fórumla: (w1,w2,3,...,wk) = (X - /X)T * (u1,u2,...,uk)",
            "respostes": {
                "a": "Obtenemos las coordenadas (w1,w2,w3,...,wk) de la imagen X en el espacio de los eigenfaces",
                "b": "(w1,w2,w3,...,wk) corresponden a los valores propios de los eigenfaces.",
                "c": "(w1,w2,w3,...,wk) son las k caras más parecidas a la cara X",
                "d": "Ninguna de las anteriores"      
            },
            "correcta": "a",
            "type": "multi"
            },
            {
            "id": 84,
            "text": "(EXAMEN 2023)Dada la representación de una imagen en el espacio de los eigenfaces X = /X + sum(w_i * u_i) donde u_i son los eigenfaces, si consideramosla iamgen X2=X/2 y consideramos su representación en el espacio de los eigenfaces X2 = /X2 + sum(w_2_i * u_2_i), entonces:",
            "respostes": {
                "a": "/X2 = (/x)/2 Y w2_i = w_i/2",
                "b": "/X2 = (/x)/2 y u2_i = u_i/2",
                "c": "/X2 = (/x) y u2_i = u_i",
                "d": "Ninguna de las anteriores"
            },
            "correcta": "c",
            "type": "multi"
            },
            {
                "id": 85,
                "text": "(EXAMEN 2023)En una imagen integral construida a partir de una imagen uint8, si el píxel de la esquina abajo derecha es 0, significa que:",
                "respostes": {
                    "a": "la imagen es negra",
                    "b": "la imagen tiene tantos píxeles positivos como negativos",
                    "c": "la última fila contiene solo 0s",
                    "d": "ninguno de los anteriores"
                },
                "correcta": "a",
                "type": "multi"
            },
            
            {
                "id": 86,
                "text": "(EXAMEN 2023)Una cascada es una secuencia de clasificadores donde:",
                "respostes": {
                    "a": "Cada clasificador contiene un Adaboost que contiene un clasificador débil",
                    "b": "Cada clasificador contiene un Adaboost que intenta corregir los falsos positivos del clasificador anterior",
                    "c": "Cada clasificador contiene un Adaboost que intenta corregir los falsos negativos del clasificador anterior",
                    "d": "Ninguno de los anteriores"
                },
                "correcta": "b",
                "type": "multi"
            },
            
            {
                "id": 87,
                "text": "(EXAMEN 2023)Aplicar una característica Haar tiene complejidad:",
                "respostes": {
                    "a": "O(n*m) donde (n,m) representa el tamaño de la imagen",
                    "b": "O(1)",
                    "c": "O(n*m) donde (n,m) representa el tamaño de la característica Haar",
                    "d": "Ninguno de los anteriores"
                },
                "correcta": "b",
                "type": "multi"
            },
            
            {
                "id": 88,
                "text": "(EXAMEN 2023)Entrenamos una red neuronal:",
                "respostes": {
                    "a": "minimizando la función de puntuación (score function)",
                    "b": "minimizando la función de pérdida (loss function)",
                    "c": "minimizando el número de parámetros que tiene la red",
                    "d": "Ninguno de los anteriores"
                },
                "correcta": "b",
                "type": "multi"
            },
            
            {
                "id": 89,
                "text": "(EXAMEN 2023)Una red neuronal tiene un gran número de pesos (parámetros) por entrenar que vienen principalmente de:",
                "respostes": {
                    "a": "Las capas convolucionales",
                    "b": "Las capas de activación",
                    "c": "Las capas de pooling y la función de pérdida",
                    "d": "Las capas completamente conectadas (fully connected)"
                },
                "correcta": "d",
                "type": "multi"
            },{
                "id": 90,
                "text": "Determinar la frase correcta:",
                "respostes": {
                    "a": "El método SIFT necesita como parámetro de entrada un punto o región de la imagen para calcular el descriptor del SIFT.",
                    "b": "El método SIFT calcula los puntos salientes de una imagen determinando automáticamente su posición escala orientación y calculando el descriptor de los puntos salientes.",
                    "c": "El descriptor SIFT se calcula a partir del histograma de las magnitudes del gradiente en la vecindad del punto SIFT.",
                    "d": "El descriptor SIFT es un escalar que muestra hasta qué grado el punto SIFT es saliente cuánto más saliente mayor magnitud del valor escalar."
                },
                "correcta": "b",
                "type": "multi"
            },
            {
                "id": 91,
                "text": "Dada una imagen el método SIFT:",
                "respostes": {
                    "a": "Retorna un único punto característico SIFT.",
                    "b": "Retorna cero uno o varios puntos SIFT donde el número de puntos SIFT sólo depende del tamaño de la imagen.",
                    "c": "Retorna tantos puntos característicos SIFT cuantos píxeles tiene la imagen.",
                    "d": "Retorna cero uno o varios puntos SIFT en función del contenido de la imagen."
                },
                "correcta": "d",
                "type": "multi"
            },
            {
                "id": 92,
                "text": "Dada una imagen A y el conjunto de características SIFT (SA) obtenemos la imagen B rotando A a 180 grados. Denominemos el conjunto de características SIFT de la imagen rotada SB.",
                "respostes": {
                    "a": "Los puntos de SA y SB coinciden por su localización (coordenadas xy) y descripción.",
                    "b": "Los puntos de SA y SB coinciden en su localización (coordenadas xy).",
                    "c": "SA y SB coinciden en su descripción pero no en su localización (coordenadas xy).",
                    "d": "SA y SB no coinciden ni en su descripción ni en su localización (coordenadas xy)."
                },
                "correcta": "b",
                "type": "multi"
            },
            {
                "id": 93,
                "text": "Dada una imagen con el logo de UB para comprobar si una segunda imagen contiene el mismo logo utilizando la correspondencia de puntos:",
                "respostes": {
                    "a": "Podemos utilizar el método SIFT si las 2 imágenes enteras representan el logo pero el SIFT no funciona si una imagen representa el logo y en la otra el logo es una subregión de la imagen.",
                    "b": "El método SIFT funcionaría sólo si los logos son subregiones de las 2 imágenes y su fondo son imágenes homogéneas.",
                    "c": "El método de SIFT nos serviría si utilizamos logo en color pero no en blanco y negro.",
                    "d": "Podemos utilizar el método SIFT (convirtiendo las imágenes en niveles de gris) y cuántas más correspondencias de puntos SIFT encontremos en las dos imágenes más probable es que la segunda imagen contenga el logo."
                },
                "correcta": "d",
                "type": "multi"
            },
            {
                "id": 94,
                "text": "Los métodos automáticos de análisis de texturas basados en el banco de los filtros de la Gaussiana están diseñados para discriminar:",
                "respostes": {
                    "a": "Las texturas estocásticas de las estructurales.",
                    "b": "Las texturas preatentivamente discriminantes de las texturas preatentivamente no discriminantes.",
                    "c": "Las texturas naturales de las artificiales.",
                    "d": "Los filtros de las derivadas de la Gaussiana están basados en la estadística de las respuestas de las derivadas de la Gaussiana para discriminar las diferentes texturas en las imágenes."
                },
                "correcta": "d",
                "type": "multi"
            },
            {
                "id": 95,
                "text": "El banco de filtros de la Gaussiana para analizar las texturas es:",
                "respostes": {
                    "a": "Invariante a la rotación es decir si una imagen la rotamos el banco nos dará exactamente el mismo descriptor.",
                    "b": "Invariante a la escala es decir si una imagen la reescalamos el banco nos dará exactamente el mismo descriptor.",
                    "c": "Son invariantes a la rotación y a la escala.",
                    "d": "Ninguno de las anteriores."
                },
                "correcta": "d",
                "type": "multi"
            },
            {
                "id": 96,
                "text": "La ventaja principal de los LBPs respecto el banco de filtros de la Gaussiana es:",
                "respostes": {
                    "a": "Que es invariante a la iluminación ya que está basado en la relación de la orientación del gradiente.",
                    "b": "Que es invariante a la iluminación ya que está basado en la relación de la intensidad de los píxeles.",
                    "c": "Que es invariante a la escala ya que el método calcula los LBPs en ventanas de diferente escala y selecciona la escala que da máxima respuesta.",
                    "d": "Que automáticamente y de forma explícita retorna información tanto sobre la magnitud de la textura como de su orientación."
                },
                "correcta": "b",
                "type": "multi"
            },
            {
                "id": 97,
                "text": "Decimos que dos imágenes con texturas son diferentes si:",
                "respostes": {
                    "a": "Todos los filtros del banco de filtros de la Gaussiana retornan valores muy diferentes.",
                    "b": "Por lo menos algunos de los filtros del banco de filtros de la Gaussiana tienen valores muy diferentes.",
                    "c": "Si hay uno y sólo un filtro del banco de filtros de la Gaussiana que tiene para las dos imágenes valores muy diferentes.",
                    "d": "Si todos los filtros que representan la primera derivada de la Gaussiana tienen valores muy diferentes."
                },
                "correcta": "b",
                "type": "multi"
            },
            {
                "id": 98,
                "text": "El método de Viola-Jones de detección de caras es un método de aprendizaje automático porque:",
                "respostes": {
                    "a": "Utiliza kmeans para detectar el clúster que corresponde a una cara vs no cara.",
                    "b": "Utiliza un conjunto de imágenes de aprendizaje para entrenar un clasificador en particular el Adaboost.",
                    "c": "Utiliza el método de knn para detectar si una imagen o una región de una imagen representa una cara.",
                    "d": "Utiliza características Haar que después las proyecta y agrupa en el espacio de los eigenfaces para decidir si una imagen o una región es una cara o no."
                },
                "correcta": "b",
                "type": "multi"
            },
            {
                "id": 99,
                "text": "Una característica Haar está determinada por:",
                "respostes": {
                    "a": "Un conjunto de 2 o 3 rectángulos con signos opuestos (1 y -1) que se aplica en una posición concreta de la imagen.",
                    "b": "Un conjunto de 2 o 3 rectángulos con signos opuestos que se aplican sobre toda la imagen.",
                    "c": "Un conjunto de 1 o 2 rectángulos con signos opuestos (1 y -1) que se aplica sobre la imagen en una posición concreta.",
                    "d": "Una máscara que puede tener cualquier valor y que se aplica sobre la imagen en una posición concreta para entrenar un clasificador."
                },
                "correcta": "a",
                "type": "multi"
            },
            {
                "id": 100,
                "text": "Dada una imagen de caras podemos obtener la imagen integral:",
                "respostes": {
                    "a": "Aplicando el integral sobre la imagen original.",
                    "b": "Aplicando un banco de filtros de las derivadas de la Gaussiana.",
                    "c": "A partir de la imagen original sumando los valores de todos los píxeles a la izquierda y hacia arriba.",
                    "d": "Convolucionando la imagen original con un conjunto de características Haar."
                },
                "correcta": "c",
                "type": "multi"
            },
            {
                "id": 101,
                "text": "Una cascada de clasificadores:",
                "respostes": {
                    "a": "Es sinónimo de un clasificador Adaboost.",
                    "b": "Es un conjunto de clasificadores débiles.",
                    "c": "Es un conjunto de clasificadores Adaboost donde cada Adaboost es un conjunto de clasificadores débiles.",
                    "d": "Es un conjunto de clasificadores Adaboost donde cada Adaboost intenta corregir el error del anterior recuperando las imágenes de caras que haya perdido el anterior."
                },
                "correcta": "d",
                "type": "multi"
            },
            {
                "id": 102,
                "text": "El método de reconocimiento de caras basado en eigenfaces:",
                "respostes": {
                    "a": "Tiene como objetivo aplicar el método del análisis de los componentes principales para encontrar los eigenfaces donde cada eigenface es un prototipo que representa una persona. Dada una nueva imagen de una cara la clasificación consiste en encontrar a qué eigenface se parece esta cara.",
                    "b": "Pretende encontrar un nuevo espacio que tiene como bases los eigenfaces donde se hace la clasificación. La ventaja de este nuevo espacio es que es de menor dimensionalidad que el espacio original de las caras y que representa mejor las caras.",
                    "c": "Pretende construir una cascada de eigenfaces para reconocer personas.",
                    "d": "Se puede aplicar sólo si las imágenes están en color."
                },
                "correcta": "b",
                "type": "multi"
            },
            {
                "id": 103,
                "text": "El problema de reconocimiento de caras es:",
                "respostes": {
                    "a": "Una forma de crear un sistema biométrico.",
                    "b": "La única forma de tener un sistema biométrico.",
                    "c": "No tiene nada que ver con los sistemas biométricos.",
                    "d": "La última fase en cualquier sistema biométrico."
                },
                "correcta": "a",
                "type": "multi"
            },
            {
                "id": 104,
                "text": "En el espacio de los eigenfaces cada punto:",
                "respostes": {
                    "a": "Corresponde a una cara.",
                    "b": "Corresponde a un píxel de una cara.",
                    "c": "Corresponde a una fila de una imagen de una cara.",
                    "d": "Corresponde a un eigenface."
                },
                "correcta": "a",
                "type": "multi"
            },
            {
                "id": 105,
                "text": "En el espacio de los eigenfaces para clasificar una imagen de cara del conjunto de aprendizaje con el knn:",
                "respostes": {
                    "a": "Antes hemos de aplicar un clustering con kmeans para agrupar todos los ejemplos de caras de la misma persona.",
                    "b": "El método nos dará error ya que por definición el conjunto de aprendizaje y test han de ser diferentes.",
                    "c": "El método knn (lo más probable) nos retornará la misma imagen.",
                    "d": "El método knn nos retornará la eigenface más parecida."
                },
                "correcta": "c",
                "type": "multi"
            },
            {
                "id": 106,
                "text": "Dada una imagen I de tipo float e I2=I/2",
                "respostes": {
                    "a": "La localización de los puntos SIFT de I e I2 coincide",
                    "b": "La localización de la mitad de los puntos SIFT de I coinciden con los puntos SIFT de I2",
                    "c": "No solo la localización de los puntos SIFT de I e I2 coincide, pero además los descriptores de I2 se pueden obtener dividiendo los descriptores de I por 2",
                    "d": "Ninguno de los anteriores."
                },
                "correcta": "a",
                "type": "multi"
            },
            {
                "id": 107,
                "text": "El ORB es una alternativa de:",
                "respostes": {
                    "a": "el detector de esquina de Harris",
                    "b": "el detector SIFT de características de la imagen",
                    "c": "los puntos CENSURE",
                    "d": "Ninguno de los anteriores."
                },
                "correcta": "b",
                "type": "multi"
            },
            {
                "id": 108,
                "text": "El método RANSAC se utiliza:",
                "respostes": {
                    "a": "Para detectar puntos característicos (esquinas) en la imagen equivalentes a los puntos SIFT",
                    "b": "Para detectar la transformación de los puntos SIFT de una imagen a otra",
                    "c": "Para calcular la precisión de la detección de puntos características en una imagen (como por ejemplo puntos SIFT)",
                    "d": "Ninguno de los anteriores."
                },
                "correcta": "b",
                "type": "multi"
            },
            {
                "id": 109,
                "text": "El banco de filtros de la Gausiana visto en clase para caracterizar texturas:",
                "respostes": {
                    "a": "Contiene derivadas de la Gausiana de orden 1",
                    "b": "Contiene derivadas de la Gausiana de orden 2",
                    "c": "Contiene derivadas de la Gausiana de orden 01 y 2",
                    "d": "Ninguno de los anteriores."
                },
                "correcta": "c",
                "type": "multi"
            },
            {
                "id": 110,
                "text": "En el Local Binary Patterns usamos el histograma para:",
                "respostes": {
                    "a": "Calcular la frecuencia de los números decimales que codifican los correspondientes números binarios representando la relación entre las intensidades del píxel central y sus vecinos",
                    "b": "Para construir un histograma del gradiente",
                    "c": "Para calcular la frecuencia de los valores del pixel central y de los vecinos",
                    "d": "Ninguno de los anteriores."
                },
                "correcta": "a",
                "type": "multi"
            },
            {
                "id": 111,
                "text": "El descriptor de texturas basado en Local binary patterns es invariante a:",
                "respostes": {
                    "a": "La orientación de la textura",
                    "b": "La escala de la textura",
                    "c": "El cambio de contraste de las imágenes",
                    "d": "Ninguno de los anteriores."
                },
                "correcta": "c",
                "type": "multi"
            },
            {
                "id": 112,
                "text": "En una imagen integral construida a partir de cualquier imagen, el píxel más abajo y a la derecha:",
                "respostes": {
                    "a": "es la suma de todos los píxeles de la imagen integral",
                    "b": "es la suma de todos los píxeles de la imagen original",
                    "c": "es el resultado de aplicar una convolución sobre la imagen original con una máscara de tamaño de la imagen original",
                    "d": "Ninguno de los anteriores."
                },
                "correcta": "b",
                "type": "multi"
            },
            {
                "id": 113,
                "text": "Los clasificadores débiles en el clasificador Adaboost se necesitan para construir el clasificador Adaboost donde añadimos el siguiente clasificador débil para",
                "respostes": {
                    "a": "mejorar el último clasificador débil añadido",
                    "b": "mejorar clasificador Adaboost construido hasta la iteración actual",
                    "c": "para convolucionar con alguna de las características Haar",
                    "d": "ninguno de los anteriores."
                },
                "correcta": "b",
                "type": "multi"
            },
            {
                "id": 114,
                "text": "El clasificador cascada para detectar caras en imágenes combina:",
                "respostes": {
                    "a": "Características Haar",
                    "b": "Clasificadores débiles",
                    "c": "Clasificadores Adaboost",
                    "d": "Ninguno de los anteriores."
                },
                "correcta": "c",
                "type": "multi"
            },
            {
                "id": 115,
                "text": "El clasificador cascada para detectar caras en imágenes:",
                "respostes": {
                    "a": "Sirve sólo para detectar caras ya que las características Haar están diseñadas para “imitar” características faciales",
                    "b": "Es aplicable para detectar cualquier tipo de objetos siempre y cuando se utilizan imágenes etiquetadas de estos objetos para entrenar los adalboosts",
                    "c": "Es aplicable para detectar los eigenfaces y así reconocer las caras",
                    "d": "Ninguno de los anteriores."
                },
                "correcta": "b",
                "type": "multi"
            },
            {
                "id": 116,
                "text": "En los eigenfaces usamos el trick de los eigenfaces para",
                "respostes": {
                    "a": "Simplificar el proceso de obtener los vectores propios a partir de imágenes de tamaño más pequeño",
                    "b": "Poder aprender a reconocer las caras con menos ejemplos de caras de aprendizaje",
                    "c": "Para compactar el conjunto de imágenes de caras en un espacio de dimensionalidad menor",
                    "d": "Ninguno de los anteriores."
                },
                "correcta": "c",
                "type": "multi"
            },
            {
                "id": 117,
                "text": "En los eigenfaces, el trick de los eigenfaces tiene sentido cuando:",
                "respostes": {
                    "a": "El número de datos de aprendizaje es menor que el número de píxeles de las imágenes",
                    "b": "El número de datos de aprendizaje es mayor que el número de píxeles de las imágenes",
                    "c": "Cuando queremos reducir el número de vectores propios",
                    "d": "Ninguno de los anteriores."
                },
                "correcta": "a",
                "type": "multi"
            },
            {
                "id": 118,
                "text": "En las redes neuronales convolucionales la función de pérdida (loss) se utiliza:",
                "respostes": {
                    "a": "Dentro del descenso del gradiente para actualizar los pesos de la red",
                    "b": "Para calcular cuántas neuronas ha de tener cada capa",
                    "c": "Para calcular cuántas capas ha de tener la red neuronal",
                    "d": "Ninguno de los anteriores."
                },
                "correcta": "a",
                "type": "multi"
            },
            {
                "id": 119,
                "text": "El proceso de entrenamiento de una red (sin capas congeladas) sirve para modificar:",
                "respostes": {
                    "a": "Los pesos de las capas completamente conectadas",
                    "b": "Los pesos de las máscaras convolucionales",
                    "c": "Los parámetros de la función de pérdida",
                    "d": "a. y b."
                },
                "correcta": "d",
                "type": "multi"
            },
            {
                "id": 120,
                "text": "En una red UNET, la última capa contiene tantas neuronas",
                "respostes": {
                    "a": "cuantas clases estamos segmentando",
                    "b": "cuantos píxeles contiene la imagen original",
                    "c": "cuantos objetos hay en la imagen",
                    "d": "Ninguno de los anteriores."
                },
                "correcta": "a",
                "type": "multi"
            },
            {
                "id": 121,
                "text": "Pendiente de revisar: En el algoritmo de substracción de fondo (background substraction),",
                "respostes": {
                    "a": "Necesitamos segmentar y separar las escenas porque los objetos de foreground pueden ser diferentes",
                    "b": "Necesitamos segmentar y separar las escenas porque las diferentes escenas se han de representar con histogramas de diferente número de bins",
                    "c": "Necesitamos segmentar y separar las escenas porque el filtro de la mediana presupone que cada pixel en más de la mitad de frames del shot será estático correspondiente al fondo de esta escena",
                    "d": "Ninguno de los anteriores."
                },
                "correcta": "c",
                "type": "multi"
            },
            {
                "id": 122,
                "text": "Pendiente de revisar: Para suavizar una imagen necesitamos:",
                "respostes": {
                    "a": "Introducir ruido gausiano y aplicar una máscara de 1s.",
                    "b": "Introducir ruido tipo impulso y aplicar una máscara de 1s.",
                    "c": "Introducir ruido gausiano y aplicar una máscara de 1s.",
                    "d": "Ninguno de los anteriores."
                },
                "correcta": "c",
                "type": "multi"
            },
            {
                "id": 123,
                "text": "Pendiente de revisar: Determinar la respuesta correcta:",
                "respostes": {
                    "a": "La calidad fotométrica de las imágenes depende de la diferencia entre el nivel de gris mayor y menor.",
                    "b": "La calidad fotométrica de las imágenes depende de cuántos niveles de gris tiene en total.",
                    "c": "La calidad fotométrica de las imágenes depende del número de píxeles de la imagen.",
                    "d": "Ninguno de los anteriores."
                },
                "correcta": "b",
                "type": "multi"
            },
            {
                "id": 124,
                "text": "Pendiente de revisar: Aplicando la convolución con una máscara [[3,3,3]],",
                "respostes": {
                    "a": "Da error porque la máscara no es bidimensional",
                    "b": "Es equivalente a multiplicar la imagen por el escalar 3.",
                    "c": "Suaviza la imagen pero cambia el rango de los valores porque la máscara no está normalizada",
                    "d": "Ninguno de los anteriores."
                },
                "correcta": "b",
                "type": "multi"
            },
            {
                "id": 125,
                "text": "Pendiente de revisar: Para aumentar el contraste de una imagen:",
                "respostes": {
                    "a": "Es necesario restar de cada pixel el valor del pixel menor de la imagen y dividir por la resta del pixel mayor y pixel menor de la imagen.",
                    "b": "Es necesario pasar la imagen en tipo float, de esta forma el skimage automáticamente aumenta el contraste.",
                    "c": "Es necesario convolucionar la imagen con una máscara compuesta de 1s y -1s.",
                    "d": "Ninguno de los anteriores."
                },
                "correcta": "a",
                "type": "multi"
            },
            {
                "id": 126,
                "text": "Pendiente de revisar: Decimos que una convolución es un filtro lineal, porque",
                "respostes": {
                    "a": "sumamos los coeficientes de una máscara a cada pixel y sus vecinos para obtener el valor del pixel en la imagen de resultado",
                    "b": "multiplicamos cada pixel con sus vecinos para obtener el valor del pixel en la imagen de resultado",
                    "c": "multiplicamos cada píxel y sus vecinos con los coeficientes de una máscara y sumamos estas multiplicaciones para obtener el valor del pixel en la imagen de resultado",
                    "d": "Ninguno de los anteriores."
                },
                "correcta": "c",
                "type": "multi"
            },
            {
                "id": 127,
                "text": "Pendiente de revisar: Aplicando una convolución con una gausiana discretizada,",
                "respostes": {
                    "a": "Suavizamos la imagen",
                    "b": "Obtenemos los contornos de la imagen",
                    "c": "Aumentamos el contraste de la imagen",
                    "d": "Ninguno de los anteriores."
                },
                "correcta": "a",
                "type": "multi"
            },
            {
                "id": 128,
                "text": "Pendiente de revisar: El método de template matching que está basado en Normalized Cross-correlation,",
                "respostes": {
                    "a": "Es invariante a rotación del patron (template) pero no a la tralsación",
                    "b": "Es invariante a cambio de contraste pero no a la rotación del patron (template)",
                    "c": "Es invariante a cambio de contraste tanto en la imagen como en el patron (template)",
                    "d": "Ninguno de los anteriores."
                },
                "correcta": "b",
                "type": "multi"
            },
            {
                "id": 129,
                "text": "Pendiente de revisar: El descriptor en el método SIFT es:",
                "respostes": {
                    "a": "Invariante a la orientación, explorando diferentes ángulos y quedándose con la orientación de máxima respuesta",
                    "b": "Invariante a la escala de la apariencia de los objetos explorando diferentes escalas y quedándose con la escala que obtiene máxima respuesta",
                    "c": "Invariante al contraste de la imagen explorando diferentes contrastes y quedándose con el contraste de máxima respuesta",
                    "d": "Todos los anteriores."
                },
                "correcta": "d",
                "type": "multi"
            },
            {
                "id": 130,
                "text": "Pendiente de revisar: Dada una imagen I y el siguiente código: from numpy import histogram >> h2=I/2 >> h=histogram(I) >> h2=histogram(I2) Determinar la frase correcta:",
                "respostes": {
                    "a": "h2[0][0] es igual a h[0][0]/2 pero h2[0][0] es diferente de h[0][0]/2",
                    "b": "h2[1][0] es igual a h[1][0]/2 h2[1][0] es diferente a h[1][0]/2",
                    "c": "h2[1] es igual a h[1]/2",
                    "d": "h2[0] es igual a h[0]/2"
                },
                "correcta": "c",
                "type": "multi"
            }
            
            
            
    ]
}