{
    "preguntes": [
        {
            "id": 7,
            "text": "En una imagen integral construida a partir de cualquier imagen, el píxel más abajo y a la derecha:",
            "respostes": {
                "a": "Es la suma de todos los píxeles de la imagen integral",
                "b": "Es la suma de todos los píxeles de la imagen original",
                "c": "Es el resultado de aplicar una convolución sobre la imagen original con una máscara de tamaño de la imagen original",
                "d": "Ninguno de los anteriores"
            },
            "correcta": "b",
            "type": "multi"
        },
        {
            "id": 8,
            "text": "Los clasificadores débiles en el clasificador Adaboost se necesitan para construir el clasificador Adaboost donde añadimos el siguiente clasificador débil para",
            "respostes": {
                "a": "mejorar el último clasificador débil añadido",
                "b": "mejorar clasificador Adaboost construido hasta la iteración actual",
                "c": "para convolucionar con alguna de las características Haar",
                "d": "ninguno de los anteriores"
            },
            "correcta": "b",
            "type": "multi"
        },
        {
            "id": 9,
            "text": "El clasificador cascada para detectar caras en imágenes combina:",
            "respostes": {
                "a": "Características Haar",
                "b": "Clasificadores débiles",
                "c": "Clasificadores Adaboost",
                "d": "Ninguno de los anteriores"
            },
            "correcta": "c",
            "type": "multi"
        },
        {
            "id": 10,
            "text": "El clasificador cascada para detectar caras en imágenes:",
            "respostes": {
                "a": "Sirve sólo para detectar caras ya que las características Haar están diseñadas para 'imitar' características faciales",
                "b": "Es aplicable para detectar cualquier tipo de objetos siempre y cuando se utilizan imágenes etiquetadas de estos objetos para entrenar los adalboosts",
                "c": "Es aplicable para detectar los eigenfaces y así reconocer las caras",
                "d": "Ninguno de los anteriores"
            },
            "correcta": "b",
            "type": "multi"
        },
        {
            "id": 11,
            "text": "En los eigenfaces, usamos el trick de los eigenfaces para",
            "respostes": {
                "a": "Simplificar el proceso de obtener los vectores propios a partir de imágenes de tamaño más pequeño",
                "b": "Poder aprender a reconocer las caras con menos ejemplos de caras de aprendizaje",
                "c": "Para compactar el conjunto de imágenes de caras en un espacio de dimensionalidad menor",
                "d": "Ninguno de los anteriores"
            },
            "correcta": "a",
            "type": "multi"
        },
        {
            "id": 12,
            "text": "En los eigenfaces, el trick de los eigenfaces tiene sentido cuando:",
            "respostes": {
                "a": "El número de datos de aprendizaje es menor que el número de píxeles de las imágenes",
                "b": "El número de datos de aprendizaje es mayor que el número de píxeles de las imágenes",
                "c": "Cuando queremos reducir el número de vectores propios",
                "d": "Ninguno de los anteriores"
            },
            "correcta": "a",
            "type": "multi"
        },
        {
            "id": 13,
            "text": "En las redes neuronales convolucionales, la función de pérdida (loss) se utiliza:",
            "respostes": {
                "a": "Dentro del descenso del gradiente para actualizar los pesos de la red",
                "b": "Para calcular cuántas neuronas ha de tener cada capa",
                "c": "Para calcular cuántas capas ha de tener la red neuronal",
                "d": "Ninguno de los anteriores"
            },
            "correcta": "a",
            "type": "multi"
        },
        {
            "id": 14,
            "text": "El proceso de entrenamiento de una red (sin capas congeladas) sirve para modificar:",
            "respostes": {
                "a": "Los pesos de las capas completamente conectadas",
                "b": "Los pesos de las máscaras convolucionales",
                "c": "Los parámetros de la función de pérdida",
                "d": "a. y b."
            },
            "correcta": "d",
            "type": "multi"
        },
        {
            "id": 15,
            "text": "En la detección de caras utilizando el método de Viola & Jones, ¿qué papel juegan las 'imágenes integrales'?",
            "respostes": {
                "a": "Identificar características únicas de cada cara",
                "b": "Calcular rápidamente características de Haar",
                "c": "Clasificar imágenes en caras y no caras",
                "d": "Reducir el tamaño de las imágenes para procesamiento"
            },
            "correcta": "b",
            "type": "multi"
        },
        {
            "id": 16,
            "text": "¿Qué tipo de aprendizaje se utiliza en la Red Neuronal Convolucional (CNN)?",
            "respostes": {
                "a": "Aprendizaje supervisado",
                "b": "Aprendizaje no supervisado",
                "c": "Aprendizaje por refuerzo",
                "d": "Aprendizaje semi-supervisado"
            },
            "correcta": "a",
            "type": "multi"
        },
        {
            "id": 17,
            "text": "En el contexto de las Redes Neuronales Convolucionales, ¿qué función cumple la técnica de 'Max Pooling'?",
            "respostes": {
                "a": "Normalizar los pesos de la red",
                "b": "Aumentar el tamaño de la imagen de entrada",
                "c": "Reducir la dimensionalidad espacial de la representación",
                "d": "Intensificar las características de color en la imagen"
            },
            "correcta": "c",
            "type": "multi"
        },
        {
            "id": 18,
            "text": "¿Qué representa el espacio definido por los 'eigenfaces'?",
            "respostes": {
                "a": "Un subespacio de imágenes no relacionadas con caras",
                "b": "Un subespacio del espacio de imágenes que puede incluir cualquier tipo de objeto",
                "c": "Un subespacio del espacio de imágenes que representa variaciones de caras",
                "d": "Un espacio que solo contiene la imagen media deuna cara"
            },
            "correcta": "c",
            "type": "multi"
        },
        {
            "id": 19,
            "text": "En la detección de caras, ¿qué método se utiliza para calcular rápidamente las características Haar?",
            "respostes": {
                "a": "Transformada de Fourier",
                "b": "Imágenes integrales",
                "c": "Redes Neuronales Convolucionales",
                "d": "Algoritmo de Viola-Jones"
            },
            "correcta": "b",
            "type": "multi"
        },
        {
            "id": 20,
            "text": "¿Que técnica se utiliza para encontrar el subespacio reducido de los 'eigenfaces'?",
            "respostes": {
                "a": "Análisis de componentes principales (PCA)",
                "b": "Análisis de componentes independientes (ICA)",
                "c": "Análisis de componentes principales (PCA) y Análisis de componentes independientes (ICA)",
                "d": "Ninguna de las anteriores"
            },
            "correcta": "a",
            "type": "multi"
        },
        {
            "id": 21,
            "text": "¿Qué característica principal diferencia el aprendizaje supervisado del no supervisado en el contexto de las Redes Neuronales?",
            "respostes": {
                "a": "El tipo de funciones de activación utilizadas",
                "b": "El uso de etiquetas en los datos de entrenamiento",
                "c": "La velocidad de convergencia del modelo",
                "d": "La arquitectura de la red neuronal"
            },
            "correcta": "b",
            "type": "multi"
        },
        {
            "id": 22,
            "text": "En el contexto de las Redes Neuronales Convolucionales, ¿qué papel desempeña la función de activación ReLU?",
            "respostes": {
                "a": "Normalizar los datos de entrada",
                "b": "Introducir no linealidad en el modelo",
                "c": "Reducir el sobreajuste en la red",
                "d": "Aumentar la velocidad de convergencia"
            },
            "correcta": "b",
            "type": "multi"
        },
        {
            "id": 23,
            "text": "Cuanto medirá la imagen resultante de aplicar una máscara de convolución de 3x3 a una imagen de 5x5?",
            "respostes": {
                "a": "3x3",
                "b": "5x5",
                "c": "7x7",
                "d": "9x9"
            },
            "correcta": "a",
            "type": "multi"
        },
        {
            "id": 24,
            "text": "Cuanto medirá (normalmente) la última capa de una red neuronal convolucional para clasificar fotos 420x420 de tipos perro, gato, conejo?(PENDIENTE DE REVISAR)",
            "respostes": {
                "a": "3x1",
                "b": "3x3",
                "c": "3x(420x420)",
                "d": "Ninguna de las anteriores"
            },
            "correcta": "a",
            "type": "multi"
        },
        {
            "id": 25,
            "text": "Cuál de las siguientes afirmaciones es cierta?",
            "respostes": {
                "a": "El método de Viola & Jones es un método de detección de caras basado en características Haar",
                "b": "El método de Viola & Jones es un método de detección de caras basado en características SIFT",
                "c": "El método de Viola & Jones es un método de detección de caras basado en características AdaBoost",
                "d": "Ninguna de las anteriores"
            },
            "correcta": "a",
            "type": "multi"
        },
        {
            "id": 26,
            "text": "Cuál de las siguientes afirmaciones es cierta?",
            "respostes": {
                "a": "La función de pérdida (loss) se utiliza para calcular el score de una imagen",
                "b": "La función de pérdida (loss) se utiliza para calcular el error de una imagen",
                "c": "La función de pérdida (loss) se utiliza para calcular el error de una red neuronal",
                "d": "Ninguna de las anteriores"
            },
            "correcta": "c",
            "type": "multi"
        },
        {
            "id": 27,
            "text": "Cuál de las siguientes afirmaciones es FALSA ?",
            "respostes": {
                "a": "La función de entropía cruzada (cross-entropy) se utiliza para calcular el error de una red neuronal",
                "b": "La función de entropía cruzada (cross-entropy) se utiliza para dividir la imagen en regiones",
                "c": "La función de entropía cruzada (cross-entropy) se utiliza para calcular el score de una imagen",
                "d": "Ninguna de las anteriores"
            },
            "correcta": "a",
            "type": "multi"
        },
        {
            "id": 28,
            "text": "¿De que otra forma se les conoce a los eigenfaces?",
            "respostes": {
                "a": "Vectores propios",
                "b": "Lambda",
                "c": "Valores Propios",
                "d": "Ninguna de las anteriores"
            },
            "correcta": "a",
            "type": "multi"
        },
        {
            "id": 29,
            "text": "¿En la formula argmin_f(sum(error(y_i(f),y_i))) ¿Que es f?",
            "respostes": {
                "a": "La función de pérdida",
                "b": "La función de activación",
                "c": "La función de clasificación",
                "d": "Ninguna de las anteriores"
            },
            "correcta": "c",
            "type": "multi"
        },
        {
            "id": 30,
            "text": "¿En la formula argmin_f(sum(error(y_i(f),y_i))) ¿Que es y_i?",
            "respostes": {
                "a": "El valor de la imagen",
                "b": "El valor de la etiqueta",
                "c": "El valor de la función de pérdida",
                "d": "Ninguna de las anteriores"
            },
            "correcta": "b",
            "type": "multi"
        },
        {
            "id": 31,
            "text": "¿En la formula argmin_f(sum(error(y_i(f),y_i))) ¿Que es y_i(f)?",
            "respostes": {
                "a": "El valor de la predicción",
                "b": "El valor de la etiqueta",
                "c": "El valor de la función de pérdida",
                "d": "Ninguna de las anteriores"
            },
            "correcta": "a",
            "type": "multi"
        },

        {
            "id": 32,
            "text": "¿Si estamos en un clasificador con la formula f(x)=w*x+b, que es w?",
            "respostes": {
                "a": "El nodo actual",
                "b": "La imagen de entrada",
                "c": "Las clases de salida",
                "d": "La matriz de pesos"
            },
            "correcta": "d",
            "type": "multi"
        },
        {
            "id": 33,
            "text": "¿Si estamos en un clasificador con la formula f(x)=w*x+b, que es b?",
            "respostes": {
                "a": "El nodo actual",
                "b": "La imagen de entrada",
                "c": "El residuo",
                "d": "El bias"
            },
            "correcta": "d",
            "type": "multi"
        },

        {
            "id": 34,
            "text": "¿Si estamos en un clasificador con la formula f(x)=w*x+b, que es x?",
            "respostes": {
                "a": "El nodo actual",
                "b": "La imagen de entrada",
                "c": "El residuo",
                "d": "El bias"
            },
            "correcta": "b",
            "type": "multi"
        },
        {
            "id": "35",
            "text": "En una CNN, ¿cómo se suele estructurar la secuencia de capas para el procesamiento efectivo de imágenes?",
            "respostes": {
                "a": "Capa convolucional - ReLU - max-pooling y finalmente una capa completamente conectada.",
                "b": "Capa completamente conectada, seguida de max-pooling, luego ReLU y finalmente una capa convolucional.",
                "c": "Capa convolucional - luego max-pooling - RELU y finalmente una capa completamente conectada.",
                "d": "Capa max-pooling, seguida de ReLU, luego una capa convolucional y finalmente una capa completamente conectada."
            },
            "correcta": "c",
            "type": "multi"
        },
        {
            "id": "36",
            "text": "¿Qué no permite el Cascade Classifier de Viola-Jones al añadir más clasificadores?",
            "respostes": {
                "a": "Añadir falsos negativos",
                "b": "Añadir falsos positivos",
                "c": "Añadir más características Haar",
                "d": "Añadir más clasificadores débiles"
            },
            "correcta": "a",
            "type": "multi"
        },

        {
            "id": "37",
            "text": "Cual es el objetivo de la clasifiación de caracteristicas de imagenes?",
            "respostes": {
                "a": "Definir patrones de apariencia de objetos en la imagen",
                "b": "Definir un espacio de características de imagen que permite representar objetos en función de su apariencia (o a través de un conjunto de características locales) en la imagen.",
                "c": "Aplicar algoritmos de aprendizaje no supervisado para descubrir patrones ocultos en la imagen",
                "d": "Definir técnicas de transferencia de aprendizaje para mejorar el rendimiento del modelo"
            },
            "correcta": "b",
            "type": "multi"
        },
        {
            "id": "38",
            "text": "Un píxel en una imagen integral...",
            "respostes": {
                "a": "Es la suma de todos los píxeles de la imagen tras aplicar una convolución sobre la imagen original con una máscara de tamaño nxn",
                "b": "Es la suma de todos los píxeles de la imagen original que están por encima y a la izquierda de él",
                "c": "Es el resultado de la segunda derivada de la imagen original",
                "d": "Ninguno de los anteriores"

            },
            "correcta": "b",
            "type": "multi"
        },
        {
            "id": "39",
            "text": "Cuantos puntos son necesarios para calcular con la imagen integral la suma de los píxeles de una región rectangular de la imagen?",
            "respostes": {
                "a": "1",
                "b": "2",
                "c": "6",
                "d": "4"
            },
            "correcta": "d",
            "type": "multi"
        },
        {
            "id": "40",
            "text": "¿Que representan los eigenvalues?",
            "respostes": {
                "a": "Los vectores propios de la matriz de covarianza",
                "b": "Los vectores propios de la matriz de covarianza normalizada",
                "c": "Miden la variancia de la data en la direccion del eigenvector",
                "d": "Miden la variancia de la data en la direccion del eigenvector normalizado"
            },
            "correcta": "c",
            "type": "multi"
        },
        {
            "id": "41",
            "text": "Para una imagen en escala de grises (n x n) y un filtro/Kernel (f x f), el dimensiones de la imagen resultante de una operación de convolución es",
            "respostes": {
                "a": "(n-f+1) x (n-f+1)",
                "b": "(n+f-1) x (n+f-1)",
                "c": "nxf",
                "d": "fxf"
            },
            "correcta": "a",
            "type": "multi"

        },
        {
            "id":"42",
            "text": "¿Como trabajmos con diferentes escalas de la imagen en el método de Viola-Jones?",
            "respostes": {
                "a": "Reescalando la imagen y no reescalando las características",
                "b": "Reescalando la imagen y reescalando las características",
                "c": "No reescalando la imagen y reescalando las características",
                "d": "No reescalando la imagen y no reescalando las características"
            },
            "correcta": "b",
            "type": "multi"
        },
        {
            "id":"43",
            "text": "¿A que da más prioridad los nuevos clasificadores débiles en adabost?",
            "respostes": {
                "a": "A los ejemplos que se clasificaron mal en el clasificador anterior",
                "b": "A los ejemplos que se clasificaron bien en el clasificador anterior",
                "c": "A los ejemplos que se clasificaron mal en el clasificador anterior y a los ejemplos que se clasificaron bien en el clasificador anterior",
                "d": "A los ejemplos que se clasificaron mal en el clasificador anterior y a los ejemplos que se clasificaron bien en el clasificador anterior"
            },
            "correcta": "a",
            "type": "multi"
        },
{
    "id": "44",
    "text": "¿Cuál de las siguientes técnicas puede ayudar a prevenir el sobreajuste en una red neuronal recurrente (RNN)?",
    "respostes": {
        "a": "Aumentar el número de parámetros para capturar patrones más complejos.",
        "b": "Implementar una parada anticipada para detener el entrenamiento cuando el rendimiento en un conjunto de validación comienza a degradarse.",
        "c": "Eliminar el uso compartido de parámetros para garantizar que cada punto de datos se trate de forma independiente.",
        "d": "Evitar la caída del peso, ya que penalizar la magnitud de los parámetros puede provocar un desajuste."
    },
    "correcta": "b",
    "type": "multi"
},
{
    "id": "45",
    "text": "La técnica de eigenfaces es invariante a",
    "respostes": {
        "a": "La rotación de la cara",
        "b": "La escala (lo cerca de la cara)",
        "c": "La iluminación de la cara",
        "d": "Todas las anteriores"
    },
    "correcta": "c",
    "type": "multi"
}


    ]
}